package com.atscale.java.xmla.cases;

import com.atscale.java.dao.QueryHistoryDto;
import com.atscale.java.utils.CsvLoaderUtil;
import com.atscale.java.utils.PropertiesManager;
import com.atscale.java.utils.QueryHistoryFileUtil;
import io.gatling.http.response.ResponseBody;
import io.gatling.http.response.StringResponseBody;
import io.gatling.javaapi.http.HttpRequestActionBuilder;
import static io.gatling.javaapi.core.CoreDsl.*;
import static io.gatling.javaapi.http.HttpDsl.*;
import io.gatling.javaapi.core.Session;
import io.gatling.http.response.Response;
import java.nio.charset.StandardCharsets;
import java.util.function.BiFunction;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.Attributes;
import javax.xml.parsers.SAXParserFactory;

@SuppressWarnings("unused")
public class AtScaleDynamicXmlaActions {
    private static final Logger LOGGER = LoggerFactory.getLogger(AtScaleDynamicXmlaActions.class);

    public AtScaleDynamicXmlaActions() {
        super();
    }

    private List<NamedHttpRequestActionBuilder> createXmlaPayloads(List<QueryHistoryDto> history, String cubeName, String catalog, String model) {
        List<NamedHttpRequestActionBuilder> builders = new ArrayList<>();
        for (QueryHistoryDto query : history) {
                String queryName = query.getQueryName();
                String inboundTextAsHash = query.getInboundTextAsHash();
                String body = injectXmlaQuery(query.getInboundText(), cubeName, catalog);
                String atscaleQueryId = query.getAtscaleQueryId();
                String inboundText = query.getInboundText();
                String inboundTextAsBase64 = query.getInboundTextAsBase64();
                builders.add(new NamedHttpRequestActionBuilder(httpRequest(queryName, body, model), queryName, inboundTextAsHash, inboundTextAsBase64, body, atscaleQueryId, inboundText));
                LOGGER.debug("Created XMLA payload for query: {} hash: {} and body {}", queryName, query.getInboundTextAsHash(), body);
            }
            return builders;
    }

    public NamedHttpRequestActionBuilder[] createPayloadsIngestedXmlaQueries(String model, String cubeName, String catalog, String ingestionFileName, boolean hasHeader) {
        CsvLoaderUtil csvLoader = new CsvLoaderUtil(ingestionFileName, hasHeader);

        List<QueryHistoryDto> history = csvLoader.loadQueriesFromCsv();
        if (history.isEmpty()) {
            throw new IllegalArgumentException(String.format("No queries found in the history file: %s", csvLoader.getFilePath()));
        }

        for (QueryHistoryDto query : history) {
            query.bindXmla(catalog, model);
        }

        List<NamedHttpRequestActionBuilder> builders = createXmlaPayloads(history, cubeName, catalog, model);
        return builders.toArray(new NamedHttpRequestActionBuilder[0]);
    }

    public NamedHttpRequestActionBuilder[] createPayloadsXmlaQueries(String model, String cubeName, String catalog) {
        String filePath = QueryHistoryFileUtil.getXmlaFilePath(model);
        try {
            List<QueryHistoryDto> history = QueryHistoryFileUtil.readQueryHistoryFromFile(filePath);
            if (history.isEmpty()) {
                throw new IllegalArgumentException(String.format("No queries found in the history file: %s", filePath));
            }

            for (QueryHistoryDto query : history) {
                query.bindXmla(catalog, model);
            }

            List<NamedHttpRequestActionBuilder> builders = createXmlaPayloads(history, cubeName, catalog, model);
            return builders.toArray(new NamedHttpRequestActionBuilder[0]);
        } catch(FileNotFoundException e) {
            throw new RuntimeException(String.format("Query history file not found: %s.  It should be generated by running the QueryExtractExecutor. See README.md for instructions", filePath), e);
        } catch(IOException e) {
            throw new RuntimeException("Error reading query history file: " + filePath, e);
        }
    }

    // Make this protected so tests can override it to avoid initializing Gatling DSL in unit tests
    protected HttpRequestActionBuilder httpRequest(String queryName, String body, String model) {
        try {
            if (PropertiesManager.getRedactRawData(model)) {
                return http(queryName)
                        .post("")
                        .body(StringBody(body)).asXml()
                        .transformResponse(new SoapTransformerFactory().createTransformer())
                        .check(
                                status().saveAs("responseStatus"),
                                status().is(200),
                                bodyString().saveAs("responseBody")
                        );
            } else {
                return http(queryName)
                        .post("")
                        .body(StringBody(body)).asXml()
                        .requestTimeout(java.time.Duration.ofSeconds(120))
                        .check(
                                status().saveAs("responseStatus"),
                                status().is(200),
                                bodyString().saveAs("responseBody")
                        );
            }
        } catch (Exception e) {
            throw new RuntimeException("Error during HTTP request for XMLA query: " + queryName, e);
        }
    }

    private String injectXmlaQuery(String queryBody, String cube, String catalog) {
        queryBody = org.apache.commons.text.StringEscapeUtils.escapeXml11(queryBody);
        return String.format("""
                <Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/">
                    <Body>
                        <Execute xmlns="urn:schemas-microsoft-com:xml-analysis">
                            <Command>
                                <Statement>%s</Statement>
                            </Command>
                            <Properties>
                                <PropertyList>
                                    <Cube>%s</Cube>
                                    <Catalog>%s</Catalog>
                                    <UseAggregates>%s</UseAggregates>
                                    <GenerateAggregates>%s</GenerateAggregates>
                                    <UseQueryCache>%s</UseQueryCache>
                                    <UseAggregateCache>%s</UseAggregateCache>
                                </PropertyList>
                            </Properties>
                        </Execute>
                    </Body>
                </Envelope>
                """, queryBody, cube, catalog, PropertiesManager.getXmlaUseAggregates(),
                PropertiesManager.getXmlaGenerateAggregates(),
                PropertiesManager.getXmlaUseQueryCache(),
                PropertiesManager.getXmlaUseAggregateCache());
    }


    protected static class SoapTransformerFactory {

        public SoapTransformerFactory (){
            super();
            LOGGER.debug("Initialized SOAP Transformer Factory");
        }

        public BiFunction<Response, Session, Response> createTransformer() {
            return (response, session) -> {
                String hash;
                // Custom transformation logic can be added here if needed
                if(response.status().code() != 200){
                    LOGGER.warn("Response status code is not 200, skipping hash computation.  Check authorization and request validity.");
                    return response.copy(response.request(),
                            response.startTimestamp(),
                            response.endTimestamp(),
                            response.status(),
                            response.headers(),
                            new StringResponseBody("", StandardCharsets.UTF_8),
                            response.checksums(),
                            response.isHttp2()
                    );
                }
                try (var inputStream = response.body().stream()) {
                    final HashingSaxHandler handler = new HashingSaxHandler();
                    SAXParserFactory.newNSInstance().newSAXParser().parse(inputStream, handler);
                    hash = handler.getHash();
                    LOGGER.debug("Computed SOAP response hash: {}", hash);
                } catch (Exception e) {
                    throw new RuntimeException("Error computing SOAP response hash: " + e.getMessage(), e);
                }
                ResponseBody newBody = new StringResponseBody(hash, StandardCharsets.UTF_8);
                return response.copy(response.request(),
                        response.startTimestamp(),
                        response.endTimestamp(),
                        response.status(),
                        response.headers(),
                        newBody,
                        response.checksums(),
                        response.isHttp2()
                        );
            };
        }
    }

    protected static class HashingSaxHandler extends org.xml.sax.helpers.DefaultHandler {
        private final java.security.MessageDigest digest;
        private boolean isTimestampElement = false;
        private boolean isHeaderElement = false;
        private final String IGNORED_URI = "http://schemas.microsoft.com/analysisservices/2003/engine";
        private final String IGNORED_LOCAL_NAME = "LastDataUpdate";
        private final String IGNORED_HEADER_NAME = "Header";
        public HashingSaxHandler() throws java.security.NoSuchAlgorithmException {
            this.digest = java.security.MessageDigest.getInstance("SHA-256");
        }

        @Override
        public void startElement(String uri, String localName, String qName, Attributes attributes) {
            if (IGNORED_URI.equals(uri) && IGNORED_LOCAL_NAME.equals(localName)) {
                isTimestampElement = true;
            }
            if(IGNORED_HEADER_NAME.equals(localName)){
                isHeaderElement = true;
            }
        }

        @Override
        public void endElement(String uri, String localName, String qName) {
            if (IGNORED_URI.equals(uri) && IGNORED_LOCAL_NAME.equals(localName)) {
                isTimestampElement = false;
            }
            if(IGNORED_HEADER_NAME.equals(localName)){
                isHeaderElement = false;
            }
        }

        @Override
        public void characters(char[] ch, int start, int length) {
            if (!isTimestampElement && !isHeaderElement) {
                String content = new String(ch, start, length);
                // Feed content directly to SHA256 digest
                digest.update(content.getBytes(StandardCharsets.UTF_8));
            }
        }

        public String getHash() {
            byte[] hashBytes = digest.digest();
            StringBuilder sb = new StringBuilder();
            for (byte b : hashBytes) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        }
    }
}
