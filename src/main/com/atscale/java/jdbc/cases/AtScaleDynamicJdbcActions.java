package com.atscale.java.jdbc.cases;

import com.atscale.java.utils.CsvLoaderUtil;
import org.galaxio.gatling.javaapi.actions.QueryActionBuilder;
import com.atscale.java.utils.QueryHistoryFileUtil;
import com.atscale.java.dao.QueryHistoryDto;
import static org.galaxio.gatling.javaapi.JdbcDsl.*;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

public class AtScaleDynamicJdbcActions {
    private AtScaleDynamicJdbcActions() {
        // Prevent instantiation
    }

    // Tests may set this to provide a stub QueryActionBuilder that doesn't initialize the Gatling DSL.
    // If null, production code will use the real jdbc(...) builder.
    public static volatile Function<QueryHistoryDto, QueryActionBuilder> ACTION_BUILDER_FACTORY = null;

    private static List<NamedQueryActionBuilder> createBuildersJdbc(List<QueryHistoryDto> history) {
        List<NamedQueryActionBuilder> builders = new ArrayList<>();

        for (QueryHistoryDto query : history) {
            String queryName = query.getQueryName();
            String inboundTextAsHash = query.getInboundTextAsHash();
            String atscaleQueryId = query.getAtscaleQueryId();
            String inboundText = query.getInboundText();
            String inboundTextAsBase64 = query.getInboundTextAsBase64();

            QueryActionBuilder builder;
            if (ACTION_BUILDER_FACTORY != null) {
                builder = ACTION_BUILDER_FACTORY.apply(query);
            } else {
                builder = jdbc(queryName)
                    .query(query.getInboundText())
                    .check(
                        allResults().saveAs("queryResultSet")
                    );
            }

            builders.add(new NamedQueryActionBuilder(builder, queryName, inboundTextAsHash, inboundTextAsBase64, atscaleQueryId, inboundText));
        }
        return builders;

    }

    public static NamedQueryActionBuilder[] createBuildersJdbcQueries(String catalog, String model) {
        String filePath = QueryHistoryFileUtil.getJdbcFilePath(model);
        try {
            List<QueryHistoryDto> history = QueryHistoryFileUtil.readQueryHistoryFromFile(filePath);
            if (history.isEmpty()) {
                throw new IllegalArgumentException(String.format("No queries found in the history file: %s", filePath));
            } else {
                for(QueryHistoryDto query : history) {
                    query.bindJdbc(catalog, model);
                }
            }
            List<NamedQueryActionBuilder> builders = createBuildersJdbc(history);
            return builders.toArray(new NamedQueryActionBuilder[0]);

        } catch(FileNotFoundException e) {
            throw new RuntimeException(String.format("Query history file not found: %s.  It should be generated by running the QueryExtractExecutor. See README.md for instructions", filePath), e);
        } catch(IOException e) {
            throw new RuntimeException("Error reading query history file: " + filePath, e);
        }
    }

    public static NamedQueryActionBuilder[] createBuildersIngestedQueries(String ingestionFileName, boolean hasHeader, String catalog, String model) {
        CsvLoaderUtil csvLoader = new CsvLoaderUtil(ingestionFileName, hasHeader);

        List<QueryHistoryDto> history = csvLoader.loadQueriesFromCsv();
        if (history.isEmpty()) {
            throw new IllegalArgumentException(String.format("No queries found in the history file: %s",csvLoader.getFilePath().toString() ));
        }
        for(QueryHistoryDto query : history) {
            query.bindJdbc(catalog, model);
        }
        List<NamedQueryActionBuilder> builders = createBuildersJdbc(history);

        return builders.toArray(new NamedQueryActionBuilder[0]);
    }
}
